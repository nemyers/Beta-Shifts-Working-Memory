% figure2_tf_switch_plot.m - Plot time-frequency power: Switch vs. Repeat
%
% This script loads pre-calculated TF power data and generates Figure 2
% from the paper, showing oscillatory power differences between switch
% and repeat trials.
%
% KEY FINDING:
%   Switch trials show:
%   - Decreased beta power (15-25Hz) at central-parietal channels
%   - Increased theta power (4-8Hz) at frontal channels
%   - Decreased alpha power (8-14Hz) at posterior channels
%
% INPUTS:
%   - results/Figure2_TF_SwitchVsRepeat_Results_*.mat
%     (generated by figure2_tf_switch_calculate.m)
%
% OUTPUTS:
%   - Figure 2 panels (saved as PNG, EPS, PDF)
%   - Statistical results with cluster correction
%
% Author: Nicholas E. Myers
% Refactored for GitHub: 2026
% For: Myers, Stokes, & Muhle-Karbe (2026) J. Neuroscience

clearvars;
close all;
clc;

%% 1. CONFIGURATION AND DATA LOADING

% Load paths
paths = config();

% Find most recent results file
results_pattern = fullfile(paths.results, 'Figure2_TF_SwitchVsRepeat_Results_*.mat');
files = dir(results_pattern);
if isempty(files)
    error('No results file found. Run figure2_tf_switch_calculate.m first.');
end

[~, idx] = max([files.datenum]);
results_file = fullfile(files(idx).folder, files(idx).name);
fprintf('Loading results from: %s\n', results_file);
load(results_file);

% Extract data
tf_power = output.tfmu;
time_tf = output.timeTF;
frequencies = output.freq;
subject_pairs = output.subpairs;

frontal_channels = output.frontalchans;
central_channels = output.centralchans;
posterior_channels = output.postchans;

%% 2. MERGE DATA FROM SUBJECTS IN BOTH EXPERIMENTS

fprintf('Merging data from subjects in both experiments...\n');

% Average data from subjects who participated in both experiments
for i_pair = 1:size(subject_pairs, 2)
    tf_power(subject_pairs(1, i_pair), :, :, :, :) = ...
        mean(tf_power(subject_pairs(1:2, i_pair), :, :, :, :), 1);
end

% Remove duplicate entries
tf_power(subject_pairs(2, :), :, :, :, :) = [];

num_subjects = size(tf_power, 1);
fprintf('Final sample: %d subjects\n', num_subjects);

%% 3. DEFINE PLOTTING PARAMETERS

SetupPlotting();

% Define colors
color_switch = [0.20, 0.35, 0.80];  % blue
color_repeat = [0.50, 0.50, 0.50];  % grey
condition_colors = [color_switch; color_repeat];

% Time and frequency limits
time_limits = [-0.25, 1.8];
freq_limits = [1.5, 40];
baseline_time = 0;
probe_time = 0.8;

% Statistical parameters
num_permutations = 10000;
alpha_level = 0.05;

%% 4. PREPARE DATA FOR PLOTTING

% Calculate Switch - Repeat difference
% Average Repeat 1 and Repeat 2+ for main comparison
switch_power = tf_power(:, :, :, :, 1);  % Switch trials
repeat_power = mean(tf_power(:, :, :, :, [2, 3]), 5);  % Average repeats

switch_vs_repeat = switch_power - repeat_power;

% Frequency range for plotting
freq_idx = frequencies >= 2 & frequencies <= 40;
plot_frequencies = frequencies(freq_idx);

%% 5. FIGURE: TIME-FREQUENCY MAPS BY CHANNEL GROUP

channel_groups = {'Frontal', 'Central', 'Posterior'};
channel_indices = {frontal_channels, central_channels, posterior_channels};

for i_group = 1:length(channel_groups)
    
    fprintf('\nCreating TF map for %s channels...\n', channel_groups{i_group});
    
    fig = figure('Position', [100, 100, 800, 600]);
    
    % Extract data for this channel group
    group_data = permute(mean(switch_vs_repeat(:, channel_indices{i_group}, freq_idx, :), 2), ...
                        [1, 3, 4, 2]);
    
    % Handle NaN values
    group_data(isnan(group_data)) = 0;
    
    % Statistical testing with cluster correction
    fprintf('  Running cluster correction (%d permutations)...\n', num_permutations);
    p_corrected = cluster_correction(group_data, num_permutations, alpha_level);
    
    % Focus on cue-probe interval for beta analysis
    cue_probe_idx = time_tf >= 0.0 & time_tf <= probe_time;
    p_corrected_cue = cluster_correction(...
        group_data(:, :, cue_probe_idx), num_permutations, alpha_level);
    
    %% 5.1 Plot time-frequency map
    
    subplot(2, 2, 1);
    
    % Calculate mean across subjects
    mean_data = squeeze(mean(group_data, 1));
    
    % Create TF plot
    imagesc(time_tf, plot_frequencies, mean_data);
    set(gca, 'YDir', 'normal');
    
    % Mark significant clusters
    hold on;
    contour(time_tf, plot_frequencies, p_corrected < alpha_level, 1, ...
           'LineColor', 'k', 'LineWidth', 2);
    
    % Reference lines
    plot([baseline_time, baseline_time], freq_limits, 'k--', 'LineWidth', 1);
    plot([probe_time, probe_time], freq_limits, 'k--', 'LineWidth', 1);
    
    % Format
    colormap(cbrewer('div', 'RdBu', 64));
    colorbar;
    caxis([-1, 1] * max(abs(mean_data(:))));
    xlim(time_limits);
    ylim(freq_limits);
    xlabel('Time from cue (s)');
    ylabel('Frequency (Hz)');
    title(sprintf('%s Channels: Switch - Repeat', channel_groups{i_group}));
    
    %% 5.2 Topographic map
    
    subplot(2, 2, 2);
    
    % Average over cue-probe interval and beta band
    time_window = [0.4, 0.8];
    freq_band = [15, 25];
    
    time_idx = time_tf >= time_window(1) & time_tf <= time_window(2);
    freq_band_idx = frequencies >= freq_band(1) & frequencies <= freq_band(2);
    
    topo_data = squeeze(mean(mean(mean(switch_vs_repeat(:, :, freq_band_idx, time_idx), 4), 3), 1));
    
    plot_topography(topo_data, channel_indices{i_group});
    title(sprintf('Beta (%.0f-%.0f Hz)\n%.1f-%.1f s', ...
          freq_band(1), freq_band(2), time_window(1), time_window(2)));
    
    %% 5.3 Frequency profile
    
    subplot(2, 2, 3);
    
    freq_data = squeeze(mean(group_data(:, :, cue_probe_idx), 3));
    mean_freq = mean(freq_data, 1);
    sem_freq = std(freq_data, [], 1) / sqrt(num_subjects);
    
    % Plot with error patch
    plot_with_error_patch(plot_frequencies, mean_freq, sem_freq, color_switch);
    
    % Mark significant frequencies
    sig_freq = any(p_corrected_cue < alpha_level, 2);
    plot(plot_frequencies(sig_freq), ones(nnz(sig_freq), 1) * min(mean_freq), ...
        'k.', 'MarkerSize', 10);
    
    % Reference line
    plot(freq_limits, [0, 0], 'k--', 'LineWidth', 1);
    
    xlim(freq_limits);
    xlabel('Frequency (Hz)');
    ylabel('Power (dB)');
    title('Frequency Profile (Cue-Probe Interval)');
    
    %% 5.4 Time course
    
    subplot(2, 2, 4);
    
    time_data = squeeze(mean(group_data, 2));  % Average over frequencies
    mean_time = mean(time_data, 1);
    sem_time = std(time_data, [], 1) / sqrt(num_subjects);
    
    % Plot with error patch
    plot_with_error_patch(time_tf, mean_time, sem_time, color_switch);
    
    % Mark significant timepoints
    sig_time = any(p_corrected < alpha_level, 1);
    plot(time_tf(sig_time), ones(nnz(sig_time), 1) * min(mean_time), ...
        'k.', 'MarkerSize', 10);
    
    % Reference lines
    plot([baseline_time, baseline_time], ylim, 'k--', 'LineWidth', 1);
    plot([probe_time, probe_time], ylim, 'k--', 'LineWidth', 1);
    plot(time_limits, [0, 0], 'k--', 'LineWidth', 1);
    
    xlim(time_limits);
    xlabel('Time from cue (s)');
    ylabel('Power (dB)');
    title('Time Course (Average Across Frequencies)');
    
    % Save figure
    save_figure(fig, paths, 'Figure2', ...
               sprintf('TF-SwitchVsRepeat-%s', channel_groups{i_group}));
end

%% 6. PRINT STATISTICS

fprintf('\n=== Statistical Summary ===\n');

for i_group = 1:length(channel_groups)
    fprintf('\n%s Channels:\n', channel_groups{i_group});
    
    % Extract data
    group_data = permute(mean(switch_vs_repeat(:, channel_indices{i_group}, freq_idx, :), 2), ...
                        [1, 3, 4, 2]);
    group_data(isnan(group_data)) = 0;
    
    % Cluster correction
    p_corrected = cluster_correction(group_data, num_permutations, alpha_level);
    
    % Find significant clusters
    sig_clusters = find_clusters(p_corrected < alpha_level);
    
    fprintf('  Number of significant clusters: %d\n', length(sig_clusters));
    
    for i_cluster = 1:min(3, length(sig_clusters))  % Report top 3 clusters
        cluster = sig_clusters{i_cluster};
        fprintf('  Cluster %d: %.1f-%.1f Hz, %.2f-%.2f s\n', ...
               i_cluster, ...
               min(plot_frequencies(cluster.freq_range)), ...
               max(plot_frequencies(cluster.freq_range)), ...
               min(time_tf(cluster.time_range)), ...
               max(time_tf(cluster.time_range)));
    end
end

fprintf('\n=== Plotting Complete! ===\n');

%% HELPER FUNCTIONS

function p_values = cluster_correction(data, num_permutations, alpha)
    % CLUSTER_CORRECTION - Cluster-based permutation test
    %
    % Uses FieldTrip-style cluster correction for multiple comparisons
    
    % One-sample t-test at each point
    [~, p_uncorrected, ~, stats] = ttest(data);
    t_values = squeeze(stats.tstat);
    
    % Threshold t-values
    t_threshold = tinv(1 - alpha/2, size(data, 1) - 1);
    
    % Find clusters in real data
    real_clusters = find_connected_clusters(abs(t_values) > t_threshold, abs(t_values));
    
    if isempty(real_clusters)
        p_values = ones(size(p_uncorrected));
        return;
    end
    
    max_real_cluster = max([real_clusters.sum]);
    
    % Permutation distribution
    max_cluster_dist = zeros(num_permutations, 1);
    
    for i_perm = 1:num_permutations
        % Random sign flip
        perm_data = data .* (2*(rand(size(data, 1), 1) > 0.5) - 1);
        
        % T-test
        [~, ~, ~, perm_stats] = ttest(perm_data);
        perm_t = squeeze(perm_stats.tstat);
        
        % Find clusters
        perm_clusters = find_connected_clusters(abs(perm_t) > t_threshold, abs(perm_t));
        
        if ~isempty(perm_clusters)
            max_cluster_dist(i_perm) = max([perm_clusters.sum]);
        end
    end
    
    % Calculate p-value for each cluster
    p_values = ones(size(p_uncorrected));
    for i_cluster = 1:length(real_clusters)
        cluster_p = mean(max_cluster_dist >= real_clusters(i_cluster).sum);
        p_values(real_clusters(i_cluster).indices) = cluster_p;
    end
end

function clusters = find_connected_clusters(binary_mask, values)
    % FIND_CONNECTED_CLUSTERS - Find spatially/temporally connected clusters
    
    % Connected components
    labeled = bwlabel(binary_mask);
    num_clusters = max(labeled(:));
    
    clusters = [];
    for i = 1:num_clusters
        cluster_mask = labeled == i;
        clusters(i).indices = cluster_mask;
        clusters(i).sum = sum(abs(values(cluster_mask)));
        
        [freq_idx, time_idx] = find(cluster_mask);
        clusters(i).freq_range = unique(freq_idx);
        clusters(i).time_range = unique(time_idx);
    end
    
    % Sort by cluster size
    if ~isempty(clusters)
        [~, sort_idx] = sort([clusters.sum], 'descend');
        clusters = clusters(sort_idx);
    end
end

function plot_with_error_patch(x, y, sem, color)
    % PLOT_WITH_ERROR_PATCH - Plot line with shaded error region
    
    hold on;
    
    % Shaded error region
    x_patch = [x(:); flipud(x(:))];
    y_patch = [y(:) + sem(:); flipud(y(:) - sem(:))];
    patch(x_patch, y_patch, color, 'FaceAlpha', 0.25, 'EdgeColor', 'none');
    
    % Mean line
    plot(x, y, 'Color', color, 'LineWidth', 2);
end

function plot_topography(data, highlight_channels)
    % PLOT_TOPOGRAPHY - Simple topographic plot
    %
    % Note: This is a placeholder. For publication-quality topoplot,
    % use FieldTrip's ft_topoplotTFR function
    
    % Create simple representation
    imagesc(reshape(data, [], 1)');
    colormap(cbrewer('div', 'RdBu', 64));
    colorbar;
    caxis([-1, 1] * max(abs(data(:))));
    axis off;
    title('Channel Topography');
end

function save_figure(fig_handle, paths, subfolder, filename)
    % SAVE_FIGURE - Save figure in multiple formats
    
    figure_dir = fullfile(paths.results, 'figures', subfolder);
    if ~exist(figure_dir, 'dir')
        mkdir(figure_dir);
    end
    
    timestamp = datestr(now, 'yyyymmdd-HHMM');
    full_filename = fullfile(figure_dir, sprintf('%s_%s', filename, timestamp));
    
    print(fig_handle, '-dpng', full_filename);
    print(fig_handle, '-depsc2', full_filename, '-painters');
    print(fig_handle, '-dpdf', full_filename, '-painters');
    
    fprintf('Saved: %s\n', full_filename);
end

function clusters = find_clusters(binary_mask)
    % FIND_CLUSTERS - Find clusters in binary mask (simplified version)
    
    labeled = bwlabel(binary_mask);
    num_clusters = max(labeled(:));
    
    clusters = cell(num_clusters, 1);
    for i = 1:num_clusters
        cluster_mask = labeled == i;
        [freq_idx, time_idx] = find(cluster_mask);
        
        cluster_info = struct();
        cluster_info.freq_range = unique(freq_idx);
        cluster_info.time_range = unique(time_idx);
        cluster_info.size = nnz(cluster_mask);
        
        clusters{i} = cluster_info;
    end
end
